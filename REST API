controllers/controllers/index.js    
module.exports = {             
BookSales: require("./booksales"),       
Stores: require("./stores"),           
Employees: require("./employees"),          
ClientReviews: require("./clientreviews"),  
Clients: require("./clients"),                
Books: require("./books"),                 
Authors: require("./authors")                    
}          
This file is used to export each controller. Using this technique lets us import the entire folder as if it is a module:            
var controllers = require("/controllers")         
/controllers/basecontroller.js               
var _ = require("underscore"),              
restify = require("restify"),               
colors = require("colors"),                
halson = require("halson")                
function BaseController() {                  
this.actions = []                           
this.server = null                       
}                              
BaseController.prototype.setUpActions = function(app, sw) {           
this.server = app                           
_.each(this.actions, function(act) {          
var method = act['spec']['method']                         
//a bit of a logging message, to help us understand what’s going on under the hood        
console.log("Setting up auto-doc for (", method, ") - ", act['spec']['nickname'])          
sw['add' + method](act)                           
app[method.toLowerCase()](act['spec']['path'], act['action'])                              })                              }    
BaseController.prototype.addAction = function(spec, fn) {    
var newAct = {                              'spec': spec,    
action: fn                              }                  
this.actions.push(newAct)                              }    
BaseController.prototype.RESTError = function(type, msg) {     
if(restify[type]) {                       
return new restify[type](msg.toString())                           
} else {                              
console.log("Type " + type + " of error not found".red)                  
}                              }                             
/**                              Takes care of calling the "toHAL" method on every resource before writing it      
back to the client                              */                              BaseController.prototype.writeHAL = function(res, obj) {     
if(Array.isArray(obj)) {                 
var newArr = []                    
_.each(obj, function(item, k) {          
item = item.toHAL()                      
newArr.push(item)                              })         
obj = halson (newArr)                              } 
else {                              
if(obj && obj.toHAL)       
obj = obj.toHAL()                              }                 
if(!obj) {                             
obj = {}                 
}                              
res.json(obj)                              }                
module.exports = BaseController              
Every controller extends this object, gaining access to the methods shown earlier. 
We’ll use basic prototypical inheritance, as you’ll see in a bit when we start listing the other controllers’ code.
As for this one, let’s 
quickly go over the methods it exposes:               

setUpActions: This method is called upon instantiation of the controller; it is meant to add the actual routes to the HTTP server. 
This method is called during the initialization sequence for all controllers exported by the index.js file.               
addAction: This method defines an action, which consists of the specs for that action and the actual function code.
The specs are used by Swagger to create the documentation, 
but they’re also used by our code to set up the route; so there are bits inside the JSON spec that are also meant for the server,
such as the path and method attributes.   
RESTError: This is a simple wrapper method around all the error methods provided by Restify.1 It provides the benefit of cleaner code.   
writeHAL: Every model defined (as you’ll see next) has a toHAL method, and the writeHAL methods take care of calling it for every model we’re trying to render.
It basically centralizes the logic that deals with collections or simple objects, depending on what we’re trying to render.  
TipWe’re using the colors module here to print the error message from the RESTError method in red./controllers/books.js   
var BaseController = require("./basecontroller"),               
_ = require("underscore"),                        
swagger = require("swagger-node-restify")         
function Books() {                              }         
Books.prototype = new BaseController()                  
module.exports = function(lib) {                         
var controller = new Books();                           
/**                              Helper function for the POST action                              */  
function mergeStores(list1, list2) {                       
var stores1 = {}                       
var stores2 = {}                        
_.each(list1, function(st) {                      
if(st.store)                           
stores1[st.store] = st.copies                          
})                           
_.each(list2, function(st) {       
if(st.store)                          
stores2[st.store] = st.copies                              })           
var stores = _.extend(stores1, stores2)                         
return _.map(stores, function(v, k) {                       
return {store: k, copies: v}                              })  
}                             
controller.addAction({                 
'path': '/books',                           
'method': 'GET',       

'summary': 'Returns the list of books',                  
"params": [ swagger.queryParam('q', 'Search term', 'string'), swagger.queryParam('genre','Filter by genre', 'string')],     
'responseClass': 'Book',      
'nickname': 'getBooks'                       
}, function(req, res, next) {              
var criteria = {}                          
if(req.params.q) {                         
var expr = new RegExp('.*' + req.params.q + '.*')        
criteria.$or = [                      
{title: expr},                          
{isbn_code: expr},                      
{description: expr}                     
]                              }        
if(req.params.genre) {                  
criteria.genre = req.params.genre       
}                           
lib.db.model('Book')            
.find(criteria)                 
.populate('stores.store')          
.exec(function(err, books) {         
if(err) return next(err)               
controller.writeHAL(res, books)           
})                              })          
controller.addAction({                           
'path': '/books/{id}',                     
'method': 'GET',                          
'params': [ swagger.pathParam('id', 'The Id of the book','int') ],    
'summary': 'Returns the full data of a book',         
'nickname': 'getBook'                          
}, function(req, res, next) {                 
var id = req.params.id                         
if(id) {                          
lib.db.model("Book")                    

.findOne({_id: id})                       
.populate('authors')                          
.populate('stores')                            
.populate('reviews')                           
.exec(function(err, book) {                    
if(err) return 
next(controller.RESTError('InternalServerError', err))  
if(!book) {                              
return 
next(controller.RESTError('ResourceNotFoundError', 'Book not found'))                        
}                            
controller.writeHAL(res, book)                       
})                          
} else {                 
next(controller.RESTError('InvalidArgumentError', 'Missing book id'))      
}                          
})               
controller.addAction({         

'path': '/books',              
'method': 'POST',                    
'params': [ swagger.bodyParam('book', 'JSON representation of the new book','string') ],      
'summary': 'Adds a new book into the collectoin',     
'nickname': 'newBook'                         
}, function(req, res, next) {                  
var bookData = req.body                        
if(bookData) {                            
isbn = bookData.isbn_code                  
lib.db.model("Book")                         
.findOne({isbn_code: isbn})                 
.exec(function(err, bookModel) {             
if(!bookModel) {                            
bookModel = lib.db.model("Book")(bookData)            
} else {                           
bookModel.stores = mergeStores(bookModel.stores, bookData.stores)          
}                            
bookModel.save(function(err, book) {    
if(err) return next(controller.RESTError('InternalServerError', err))     
controller.writeHAL(res, book)                      
})                              })            
} else {                           
next(controller.RESTError('InvalidArgumentError', 'Missing content of book'))      
}                       
})                      
controller.addAction({  
'path': '/books/{id}/authors',   
'method': 'GET',                   
'params': [ swagger.pathParam('id', 'The Id of the book','int') ],   
'summary': 'Returns the list of authors of one specific book',       
'nickname': 'getBooksAuthors'                             
}, function(req, res, next) {                          
var id = req.params.id                            
if(id) {                             
lib.db.model("Book")                      
.findOne({_id: id})                        
.populate('authors')                        
.exec(function(err, book) {                  
if(err) return next(controller.RESTError('InternalServerError', err))              
if(!book) {                           
return 
next(controller.RESTError('ResourceNotFoundError', 'Book not found'))     
}                             
controller.writeHAL(res, book.authors)   

})                      
} else {                    
next(controller.RESTError('InvalidArgumentError', 'Missing book id'))       
}                              })                   
controller.addAction({                        
'path': '/books/{id}/reviews',                  
'method': 'GET',                            
'params': [ swagger.pathParam('id', 'The Id of the book','int') ],        
'summary': 'Returns the list of reviews of one specific book',       
'nickname': 'getBooksReviews'                          
}, function(req, res,next) {                          
var id = req.params.id                        
if(id) {                             
lib.db.model("Book")               
.findOne({_id: id})                  
.populate('reviews')                 
.exec(function(err, book) {             
if(err) return next(controller.RESTError('InternalServerError', err))                       
if(!book) {                 
return 
next(controller.RESTError('ResourceNotFoundError', 'Book not found'))          
}                           
controller.writeHAL(res, book.reviews)                              
})                              }

else {                      
next(controller.RESTError('InvalidArgumentError', 'Missing book id'))     
}                              })                   
controller.addAction({                            
'path': '/books/{id}',                            
'method': 'PUT',                          
'params': [ swagger.pathParam('id', 'The Id of the book to update','string'),                             
swagger.bodyParam('book', 'The data to change on the book', 'string') ],                         
'summary': 'Updates the information of one specific book',                          
'nickname': 'updateBook'                         
}, function(req, res, next) {                      
var data = req.body                  
var id = req.params.id                   
if(id) {                            
lib.db.model("Book").findOne({_id: id}).exec(function(err, book) 
{                        
if(err) return 
next(controller.RESTError('InternalServerError', err))            
if(!book) 
return 
next(controller.RESTError('ResourceNotFoundError', 'Book not found'))   
book = _.extend(book, data)                            
book.save(function(err, data) {                   
if(err) return next(controller.RESTError('InternalServerError', err))  
controller.writeHAL(res, data.toJSON())                        
})                             
})                          
} else {       
next(controller.RESTError('InvalidArgumentError', 'Invalid id received'))    
}                              })    
return controller                              }   
The code for this controller is very straightforward; 
in it are the basic mechanics defined for this particular project on how to declare a controller and its actions.
We also have a special case for the POST action, 
which checks the ISBN of a new book to see if it is in stock at another store.
If an ISBN already exists, the book is merged to all relevant stores; 
otherwise, a new record is created.In theory, we’re creating a new function that inherits from the BaseController, 
which gives us the ability to add custom behavior on a specific controller. 
Reality is going to prove that we don’t really need such liberties, 
however. And we could very well do the same by instantiating the BaseController directly on every other controller file.The controller files are required during initialization of the API, and when that happens, the lib object is passed to them, like so: 
var controller = require("/controllers/books.js")(lib) 
This means that (as you see in the preceding code), 
the lib object is received by the export function, 
which is in charge of instantiating the new controller and adding actions to it to return it to the required code.
Here are some other interesting bits from the code:
The getBooks action shows how to do simple regular expression–based filtering with Mongoose.
The update action is not actually using the update method from Mongoose,
but instead loads the model using the extend method from the underscore, 
and finally calls the save method on the model. 
This is done for one simple reason: the update method doesn’t trigger any post hooks on the models, 
but the save method does, 
so if we wanted to add behavior to react to an update on the model, this would be the way to go about it.       
/controllers/stores.js       
var BaseController = require("./basecontroller"),  
_ = require("underscore"),                
swagger = require("swagger-node-restify") 
function Stores() {                           
}                             
Stores.prototype = new BaseController()    
module.exports = function(lib) {           
var controller = new Stores();             

controller.addAction({                     
'path': '/stores',                          
'method': 'GET',                            
'summary': 'Returns the list of stores ',   
'params': [swagger.queryParam('state', 'Filter the list of stores by state', 'string')],          
'responseClass': 'Store',          
'nickname': 'getStores'           
}, function (req, res, next) {     
var criteria = {}                   
if(req.params.state) {                 
criteria.state = new RegExp(req.params.state,'i')     
}                             
lib.db.model('Store')      
.find(criteria)                   
.exec(function(err, list) {         
if(err) 
return 
next(controller.RESTError('InternalServerError', err))         
controller.writeHAL(res, list)                         
})                              })    
controller.addAction({                     
'path': '/stores/{id}',                         
'method': 'GET',                            
'params': [swagger.pathParam('id','The id of the store','string')],   
'summary': 'Returns the data of a store',                 
'responseClass': 'Store',                           
'nickname': 'getStore'                             
}, function(req, res, next) {                        
var id = req.params.id           
if(id) {                          

lib.db.model('Store')             
.findOne({_id: id})                 

.populate('employees')              
.exec(function(err, data) {         
if(err) return 
next(controller.RESTError('InternalServerError', err))                    
if(!data) return 
next(controller.RESTError('ResourceNotFoundError', 'Store not found')) 
controller.writeHAL(res, data)                   
})                            
} else  {              
next(controller.RESTError('InvalidArgumentError', 'Invalid id'))     
}                       
})                     
controller.addAction({     
'path': '/stores/{id}/books',     
'method': 'GET',                
'params': [swagger.pathParam('id','The id of the store','string'),          
swagger.queryParam('q', 'Search parameter for the books', 'string'),  
swagger.queryParam('genre', 'Filter results by genre', 'string')],    
'summary': 'Returns the list of books of a store',                    
'responseClass': 'Book',                           
'nickname': 'getStoresBooks'                        
}, function (req, res, next) {            
var id = req.params.id                 
if(id) {                          
var criteria = {stores: id}              
if(req.params.q) {                          
var expr = new RegExp('.*' + req.params.q + '.*', 'i')     
criteria.$or = [                           
{title: expr},                             
{isbn_code: expr},                         

{description: expr}                              ]    
}                          
if(req.params.genre) {      
criteria.genre = req.params.genre     
}                             
//even though this is the stores controller, we deal directly with books here      
lib.db.model('Book')                   
.find(criteria)                      
.populate('authors')                  
.exec(function(err, data) {            
if(err) return next(controller.RESTError('InternalServerError', err))       
controller.writeHAL(res, data)           
})                            
} else  {              
next(controller.RESTError('InvalidArgumentError', 'Invalid id'))          
}                         
})                       
controller.addAction({     
'path': '/stores/{id}/employees',    
'method': 'GET',                     
'params': [swagger.pathParam('id','The id of the store','string')],   
'summary': 'Returns the list of employees working on a store',      
'responseClass': 'Employee',                            
'nickname': 'getStoresEmployees'                         
}, function (req, res, next) {               
var id = req.params.id             
if(id) {                         
lib.db.model('Store')              
.findOne({_id: id})                  
.populate('employees')                 
.exec(function(err, data) {               
if(err) 
return 
next(controller.RESTError('InternalServerError', err))      

if(!data) {            
return 
next(controller.RESTError('ResourceNotFoundError', 'Store not found'))      
}                             
console.log(data)          
controller.writeHAL(res, data.employees)   
})                              } else  {   
next(controller.RESTError('InvalidArgumentError', 'Invalid id'))           
}                           
})                           
controller.addAction({               
'path': '/stores/{id}/booksales',      
'method': 'GET',                         
'params': [swagger.pathParam('id','The id of the store','string')],  
'summary': 'Returns the list of booksales done on a store',   
'responseClass': 'BookSale',                      
'nickname': 'getStoresBookSales'                
}, function (req, res, next) {                          
var id = req.params.id                     
if(id) {                         
//even though this is the stores controller, we deal directly with booksales here        
lib.db.model('Booksale')                       
.find({store: id})                           
.populate('client')                          
.populate('employee')                        
.populate('books')                         
.exec(function(err, data) {                  
if(err) return next(controller.RESTError('InternalServerError', err))          
controller.writeHAL(res, data)                       
})                          
} else  {             
next(controller.RESTError('InvalidArgumentError', 'Invalid id'))       
}                          
})                           
controller.addAction({       
'path': '/stores',                       
'method': 'POST',                  
'summary': 'Adds a new store to the list',  
'params': [swagger.bodyParam('store', 'The JSON data of the store', 'string')],      
'responseClass': 'Store',                    
'nickname': 'newStore' 
}, function (req, res, next) { 
var data = req.body        
if(data) {              
var newStore = lib.db.model('Store')(data)  
newStore.save(function(err, store) {    
if(err) return next(controller.RESTError('InternalServerError', err))  
res.json(controller.toHAL(store))                       
})                            
} else {      
next(controller.RESTError('InvalidArgumentError', 'No data received'))           
}                           
})                   
controller.addAction({     
'path': '/stores/{id}',     
'method': 'PUT',             
'summary': "UPDATES a store's information",        
'params': [swagger.pathParam('id','The id of the store','string'), 
swagger.bodyParam('store', 'The new information to update', 'string')],  
'responseClass': 'Store',                            
'nickname': 'updateStore'                            
}, function (req, res, next) {                     
var data = req.body                           

var id = req.params.id                        
if(id) {                    
lib.db.model("Store").findOne({_id: id}).exec(function(err, store) {        
if(err) return next(controller.RESTError('InternalServerError', err))   
if(!store) return next(controller.RESTError('ResourceNotFoundError', 'Store not found'))    
store = _.extend(store, data)                      
store.save(function(err, data) {                     
if(err) return next(controller.RESTError('InternalServerError', err))     
res.json(controller.toHAL(data))                              })    
})                              
} else {      

next(controller.RESTError('InvalidArgumentError', 'Invalid id received'))     
}                          
})                      
return controller      
}              
The code for the Stores controller is very similar to that of the Books controller. It does, however,
have something of notice:
the getStoresBookSales action clearly shows what happens when we don’t use a Hierarchical MVC model.
I said that this is not a common case,
so it would be fine for the purpose of this book,
but it shows how separation of concerns is broken in the strictest of senses by acting over the model of another controller, 
instead of going through that other controller. 
Given the added complexity that mechanism would imply to our code, 
we’re better off looking the other way for the time being.Here are the remaining controllers. 
They don’t particularly show anything new compared to the previous ones, 
so just look at the code and the occasional code comment./controllers/authors.js 
var BaseController = require("./basecontroller"),      
swagger = require("swagger-node-restify")             
function BookSales() {                
} 
BookSales.prototype = new BaseController()      
module.exports = function(lib) {                 
var controller = new BookSales()  
//list                          
controller.addAction({           
'path': '/authors',               4
'method': 'GET',               
'summary' :'Returns the list of authors across all stores',   
'params': [ swagger.queryParam('genre', 'Filter authors by genre of their books', 'string'),         
swagger.queryParam('q', 'Search parameter', 'string')],                   
'responseClass': 'Author',                           
'nickname': 'getAuthors'                            
}, function(req, res, next) {                       
var criteria = {}                         
if(req.params.q) {                         
var expr = new RegExp('.*' + req.params.q + '.*', 'i')   
criteria.$or = [                           
{name: expr},                           
{description: expr}                      
]                         
}                           
var filterByGenre = false || req.params.genre     
if(filterByGenre) {                           
lib.db.model('Book')                        
.find({genre: filterByGenre})                 
.exec(function(err, books) {                  
if(err) 
return 
next(controller.RESTError('InternalServerError', err))           
findAuthors(_.pluck(books, '_id'))                 
})                       
} else {             
findAuthors()     
}                   
function findAuthors(bookIds) {       
if(bookIds) {                        
criteria.books = {$in: bookIds}    
}                           
lib.db.model('Author')       
.find(criteria)                 
.exec(function(err, authors) {    
if(err) return next(controller.RESTError('InternalServerError', err))      
controller.writeHAL(res, authors)              
})                          
}                          
})                           
//get                       
controller.addAction({         
'path': '/authors/{id}',          
'summary': 'Returns all the data from one specific author',    
'method': 'GET',                          
'responseClass': 'Author',                    
'nickname': 'getAuthor'                        
}, function (req, res, next) {                        
var id = req.params.id                        
if(id) {                      
lib.db.model('Author')                
.findOne({_id: id})                     
.exec(function(err, author) {           
if(err) 
return
next(controller.RESTError('InternalServerError', err))    

if(!author) {                 
return 
next(controller.RESTError('ResourceNotFoundError', 'Author not found'))       
}                           
controller.writeHAL(res, author)    
})                             
} else {              
next(controller.RESTError('InvalidArgumentError', 'Missing author id'))             
}                             
})                         
//post                   
controller.addAction({     
'path': '/authors',         
'summary': 'Adds a new author to the database',    
'method': 'POST',                         
'params': [swagger.bodyParam('author', 'JSON representation of the data', 'string')],          
'responseClass': 'Author',                          
'nickname': 'addAuthor'                           
}, function (req, res, next) {            
var body = req.body                    
if(body) {                        
var newAuthor = lib.db.model('Author')(body)    
newAuthor.save(function(err, author) {       
if(err) return next(controller.RESTError('InternalServerError', err))   
controller.writeHAL(res, author)                  
})                            
} else {                
next(controller.RESTError('InvalidArgumentError', 'Missing author id'))         
}                              })                       
//put                            
controller.addAction({             
'path': '/authors/{id}',              
'method': 'PUT',                         
'summary': "UPDATES an author's information",      
'params': [swagger.pathParam('id','The id of the author','string'),       
swagger.bodyParam('author', 'The new information to update', 'string')],          
'responseClass': 'Author',                           
'nickname': 'updateAuthor'  
}, function (req, res, next) {  
var data = req.body          
var id = req.params.id     
if(id) {                     
lib.db.model("Author").findOne({_id: id}).exec(function(err, author) {       
if(err) return next(controller.RESTError('InternalServerError', err))      
if(!author) return next(controller.RESTError('ResourceNotFoundError', 'Author not found'))    
author = _.extend(author, data)                  
author.save(function(err, data) {          
if(err) return next(controller.RESTError('InternalServerError', err))          
res.json(controller.toHAL(data))                       
})                     
})          
} else {             
next(controller.RESTError('InvalidArgumentError', 'Invalid id received'))         
}                            
})                 
// /books                          
controller.addAction({       
'path': '/authors/{id}/books',    
'summary': 'Returns the data from all the books of one specific author',  
'method': 'GET',                            
'params': [ swagger.pathParam('id', 'The id of the author', 'string')],        
'responseClass': 'Book',                           
'nickname': 'getAuthorsBooks'                       
}, function (req, res, next) {                       
var id = req.params.id                         
if(id) {                       
lib.db.model('Author')             
.findOne({_id: id})                  
.populate('books')                       
.exec(function(err, author) {           
if(err) return next(controller.RESTError('InternalServerError', err))    
if(!author) {                         
return next(controller.RESTError('ResourceNotFoundError', 'Author not found'))        
}                         
controller.writeHAL(res, author.books)      
})                            
} else {                 
next(controller.RESTError('InvalidArgumentError', 'Missing author id'))           
}                         
})                            
return controller          
}             
/controllers/booksales.js       
var BaseController = require("./basecontroller"),      
swagger = require("swagger-node-restify")         
function BookSales() {                              }
BookSales.prototype = new BaseController()        
module.exports = function(lib) {        
var controller = new BookSales();     
controller.addAction({                   
'path': '/booksales',                     
'method': 'GET',                          
'summary': 'Returns the list of book sales',     
'params': [ swagger.queryParam('start_date', 'Filter sales done after (or on)  
this date', 'string'),                         
swagger.queryParam('end_date', 'Filter sales done on or before this date', 'string'),    
swagger.queryParam('store_id', 'Filter sales done  on this store', 'string')            
],                           
'responseClass': 'BookSale',     
'nickname': 'getBookSales'       
}, function(req, res, next) {      
console.log(req)                      
var criteria = {}                   
if(req.params.start_date)         
criteria.date = {$gte: req.params.start_date}       
if(req.params.end_date)                   
criteria.date = {$lte: req.params.end_date}     
if(req.params.store_id)                      
criteria.store = req.params.store_id      
lib.db.model("Booksale")                  

.find(criteria)       
.populate('books')         
.populate('client')             
.populate('employee')             
.populate('store')                  
.exec(function(err, sales) {          
if(err) return next(controller.RESTError('InternalServerError', err))        
controller.writeHAL(res, sales)                        
})                              })               
controller.addAction({                      
'path': '/booksales',                      
'method': 'POST',                        
'params': [ swagger.bodyParam('booksale', 'JSON representation of the new booksale','string') ],      
'summary': 'Records a new booksale',        
'nickname': 'newBookSale'                
}, function(req, res, next) {                  
var body = req.body                          
if(body) {                         
var newSale = lib.db.model("Booksale")(body)    
newSale.save(function(err, sale) {        
if(err) return next(controller.RESTError('InternalServerError', err))                
controller.writeHAL(res, sale)                         
})                          
} else {                     
next(controller.RESTError('InvalidArgumentError', 'Missing json data'))     
}                            
})                            
return controller      
}         

/controllers/clientreviews.js  
var BaseController = require("./basecontroller"),   
_ = require("underscore"),                 
swagger = require("swagger-node-restify") 
function ClientReviews() {            
}                         
ClientReviews.prototype = new BaseController()              
module.exports = function(lib) {                  
var controller = new ClientReviews();       
controller.addAction({                    4
'path': '/clientreviews',              
'method': 'POST',                   
'summary': 'Adds a new client review to a book',    
'params': [swagger.bodyParam('review', 'The JSON representation of the review',  'string')],   
'responseClass': 'ClientReview',              
'nickname': 'addClientReview'               
}, function (req, res, next) {             
var body = req.body                    
if(body) {                         
var newReview = lib.db.model('ClientReview')(body)     
newReview.save(function (err, rev) {      
if(err) return next(controller.RESTError('InternalServerError', err))        
controller.writeHAL(res, rev)                        
})                          
}                            
})                          
return controller            
}            
/controllers/clients.js       
var BaseController = require("./basecontroller"),     
_ = require("underscore"),                  
swagger = require("swagger-node-restify")
function Clients() {                
}                          
Clients.prototype = new BaseController()       
module.exports = function(lib) {      
var controller = new Clients();    

controller.addAction({          
'path': '/clients',           
'method': 'GET',           
'summary': 'Returns the list of clients ordered by name',                 
'responsClass':'Client',         


'nickname': 'getClients'     
}, function(req, res, next) {  
lib.db.model('Client').find().sort('name').exec(function(err, clients) {    
if(err) return next(controller.RESTError('InternalServerError', err))        
controller.writeHAL(res, clients)  
})                           
})                             
controller.addAction({        
'path': '/clients',         
'method': 'POST',         
'params': [swagger.bodyParam('client', 'The JSON representation of the client', 'string')],   
'summary': 'Adds a new client to the database',      
'responsClass': 'Client',                        
'nickname': 'addClient'                 
}, function(req, res, next) {          
var newClient = req.body            
var newClientModel = lib.db.model('Client')(newClient)       
newClientModel.save(function(err, client) {            
if(err) return next(controller.RESTError('InternalServerError', err))   
controller.writeHAL(res, client)                           
})                              })                 
controller.addAction({                           

'path': '/clients/{id}',                      
'method': 'GET',                          
'params': [swagger.pathParam('id', 'The id of the client', 'string')],                
'summary': 'Returns the data of one client',    
'responsClass': 'Client',                    
'nickname': 'getClient'                    
}, function (req, res, next) {            
var id = req.params.id                  
if(id != null) {                      
lib.db.model('Client').findOne({_id: id}).exec(function(err, client){      
if(err) return next(controller.RESTError('InternalServerError',err)) 
if(!client) return next(controller.RESTError('ResourceNotFoundError', 'The client id cannot be found'))       
controller.writeHAL(res, client)             
})                             
} else {                     
next(controller.RESTError('InvalidArgumentError','Invalid client id'))         
}                           
})                           
controller.addAction({        

'path': '/clients/{id}',      
'method': 'PUT',           
'params': [swagger.pathParam('id', 'The id of the client', 'string'),
swagger.bodyParam('client', 'The content to overwrite', 'string')], 
'summary': 'Updates the data of one client',                       
'responsClass': 'Client',                              
'nickname': 'updateClient'                          
}, function (req, res, next) {                 
var id = req.params.id                       
if(!id) {                             
return next(controller.RESTError('InvalidArgumentError','Invalid id'))         
} else {                         
var model = lib.db.model('Client')    
model.findOne({_id: id})                 
.exec(function(err, client) {              
if(err) return next(controller.RESTError('InternalServerError', err))       
client = _.extend(client, req.body)                       
client.save(function(err, newClient) {                      
if(err) return next(controller.RESTError('InternalServerError', err))           
controller.writeHAL(res, newClient)                         
})                           
})                            
}                            
})                         
return controller     
}             
/controllers/employees.js      
var BaseController = require("./basecontroller"),     
_ = require("underscore"),                 
swagger = require("swagger-node-restify") 
function Employees() {               
}                             
Employees.prototype = new BaseController()     
module.exports = function(lib) {          
var controller = new Employees();       
controller.addAction({               
'path': '/employees',              
'method': 'GET',                
'summary': 'Returns the list of employees across all stores',       
'responseClass': 'Employee',                          
'nickname': 'getEmployees'                          
}, function(req, res, next) {                        
lib.db.model('Employee').find().exec(function(err, list) {      
if(err) return next(controller.RESTError('InternalServerError', err))           
controller.writeHAL(res, list)                         
})                              })                   
controller.addAction({                            
'path': '/employees/{id}',                      
'method': 'GET',                          
'params': [swagger.pathParam('id','The id of the employee','string')],                  
'summary': 'Returns the data of an employee',                       
'responseClass': 'Employee',                           
'nickname': 'getEmployee'                            
}, function(req, res, next) {                          
var id = req.params.id                            
if(id) {                           
lib.db.model('Employee').findOne({_id: id}).exec(function(err, empl) {  
if(err) return next(err)                       
if(!empl) {                            
return next(controller.RESTError('ResourceNotFoundError', 'Not found'))           
}                         
controller.writeHAL(res, empl)  
})                           
} else  {                
next(controller.RESTError('InvalidArgumentError', 'Invalid id'))       
}                              })                          
controller.addAction({                           
'path': '/employees',                      
'method': 'POST',                      
'params': [swagger.bodyParam('employee', 'The JSON data of the employee', 'string')],              
'summary': 'Adds a new employee to the list',                        
'responseClass': 'Employee',                          
'nickname': 'newEmployee'                        
}, function(req, res, next) {               
var data = req.body                       
if(data) {                         
var newEmployee = lib.db.model('Employee')(data)    
newEmployee.save(function(err, emp) {          
if(err) return next(controller.RESTError('InternalServerError', err))      
controller.writeHAL(res, emp)                         
})                             
} else {              
next(controller.RESTError('InvalidArgumentError', 'No data received'))        
}                              })                     
controller.addAction({                       
'path': '/employees/{id}',                
'method': 'PUT',                        
'summary': "UPDATES an employee's information",        
'params': [swagger.pathParam('id','The id of the employee','string'), 
swagger.bodyParam('employee', 'The new information to update', 'string')],    
'responseClass': 'Employee',                             
'nickname': 'updateEmployee'                         
}, function(req, res, next) {                         
var data = req.body                            
var id = req.params.id                     
if(id) {                         
lib.db.model("Employee").findOne({_id: id}).exec(function(err, emp) {  
if(err) return next(controller.RESTError('InternalServerError', err))     
emp = _.extend(emp, data)                         
emp.save(function(err, employee) {                    
if(err) return next(controller.RESTError('InternalServerError', err))    
controller.writeHAL(res, employee)                            
})                          
})                            
} else {       
next(controller.RESTError('InvalidArgumentError','Invalid id received'))      
}                          
})                            
return controller         
}          
libAs mentioned, 
the lib folder contains all sorts of helper functions and utilities that were just too small to be put into a separate folder,
but important and generic enough to be used in several places of the code./lib/index.js      
var lib = {                         
helpers: require("./helpers"),                  
config: require("./config"),            
controllers: require("../controllers"),  
schemas: require("../schemas"),            
schemaValidator: require("./schemaValidator"),    
db: require("./db")                            
}                            
module.exports = lib       
This file is supposed to act as the single point of contact between the outside world (the rest of the project) and the inside world (all of the mini-modules grouped within this folder).
There is nothing special about it. 
It just requires everything and exports using predefined keys./lib/helpers.js         
var halson = require("halson"),                         
_ = require("underscore")                       
module.exports = {                         
makeHAL: makeHAL,                    
setupRoutes: setupRoutes,          
validateKey: validateKey        
}                              
function setupRoutes(server, swagger, lib) {    
for(controller in lib.controllers) {        
cont = lib.controllers[controller](lib)    
cont.setUpActions(server, swagger)        
}                              }       
/**                              Makes sure to sign every request and compare it    
against the key sent by the client, this way            
we make sure its authentic                              */   
function validateKey(hmacdata, key, lib) {                      
//This is for testing the swagger-ui, should be removed after development to avoid possible security problem :)    
if(+key == 777) return true                     
var hmac = require("crypto").createHmac("md5", lib.config.secretKey)              
.update(hmacdata)                            
.digest("hex");                          
//TODO: Remove this line               
console.log(hmac)                  
return hmac == key               
}                            
function makeHAL(data, links, embed) {                       
var obj = halson(data)                          
if(links && links.length > 0) {               
_.each(links, function(lnk) {                 
obj.addLink(lnk.name, {                      
href: lnk.href,                           
title: lnk.title || ''                
})                           
})                           
}                       
if(embed && embed.length > 0) {   
_.each(embed, function (item) {    
obj.addEmbed(item.name, item.data)    
})                              }        
return obj                            
} 
Just as the modules exported by the index.js file are too small to merit their own folder,
these functions are too small and particular to merit their own module, 
so instead they are grouped here, inside the helpers module. 
The functions are meant to be of use (hence, the name “helpers”) throughout the entire project.L
et’s quickly go over each of these names:                
setupRoutes: This function is called from within the project’s main file during boot-up time. 
It’s meant to initialize all controllers, which in turn adds the actual route’s code to the HTTP server.         
validateKey: This function contains the code to validate the request by recalculating the HMAC key. 
And as mentioned earlier, it contains the exception to the rule, allowing any request to validate if the key sent is 777.  
makeHAL: This function turns any type of object into a HAL JSON object ready to be rendered. 
This particular function is heavily used from within the models’ code.         
/lib/schemaValidator.js              
var tv4 = require("tv4"),         
formats = require("tv4-formats"), 
schemas = require("../request_schemas/") 
module.exports = {                      
validateRequest: validate           
}                            
function validate (req) {  
var res = {valid: true}    
tv4.addFormat(formats)         
var schemaKey = req.route ? req.route.path.toString().replace("/", "") : ''     
var actionKey = req.route.name                        
if(schemas[schemaKey])        {                      
var mySchema = schemas[schemaKey][actionKey]      
var data = null                          
if(mySchema) {                         
switch(mySchema.validate) {         
case 'params':                       
data = req.params                  
break                            
}                             
res = tv4.validateMultiple(data, mySchema.schema)            
}                              }  

return res                             
}             
This file has the code that validates any request against a JSON Schema that we define. 
The only function of interest is the validate function, which validates the request object. 
It also counts on a predefined structure inside the request, 
which is added by Swagger (the route attribute).As you might’ve guessed from the preceding code, 
the validation of a request is optional; not every request is being validated. And right now, 
only query parameters are validated, but this can be extended by simply adding a new case to the switch statement.
This function works with the premise of “convention over configuration,” 
which means that if you set up everything “right,” then you don’t have to do much. 
In our particular case, we’re looking inside the request_schemas folder to load a set of predefined schemas, 
which have a very specific format. 
In that format we find the name of the action (the nickname that we set up) to validate and the portion of the request we want to validate. 
In our particular function, we’re only validating query parameters for things such as invalid formats and so forth. 
The only request we have set up to validate right now is the BookSales listing action; 
but if we wanted to add a new validation, it would just be a matter of adding a new schema—no programming 
required./lib/db.js                
var config = require("./config"),    

_ = require("underscore"),          
mongoose = require("mongoose"),       
Schema = mongoose.Schema                 
var obj = {                           
cachedModels: {},                      
getModelFromSchema: getModelFromSchema,    
model: function(mname) {                      
return this.models[mname]                       
},                          
connect: function(cb) {     
mongoose.connect(config.database.host + "/" + config.database.dbname)   
this.connection = mongoose.connection                 
this.connection.on('error', cb)                   
this.connection.on('open', cb)                 
}                              
}           
obj.models = require("../models/")(obj)          
module.exports = obj                          
function translateComplexType(v, strType) {     
var tmp = null                         
var type = strType || v['type']                       
switch(type) {                           
case 'array':                              
tmp = []                             
if(v['items']['$ref'] != null) {        
tmp.push({                          
type: Schema.ObjectId,                  
ref: v['items']['$ref']                              
})                             
} else {                            
var originalType = v['items']['type']    
v['items']['type'] = translateTypeToJs(v['items']['type'])     
tmp.push(translateComplexType(v['items'], originalType))                
}                             
break;                 
case 'object':                            
tmp = {}                           
var props = v['properties']      
_.each(props, function(data, k) {    
if(data['$ref'] != null) {           
tmp[k] = {                       
type: Schema.ObjectId,         
ref: data['$ref']                  
}                         
} else {                     
tmp[k] = translateTypeToJs(data['type'])    
}                            
})                            
break;                         
default:                      
tmp = v                       
tmp['type'] = translateTypeToJs(type)   
break;                          
}                             
return tmp                      
}                            
/**                           
Turns the JSON Schema into a Mongoose schema     
*/                              
function getModelFromSchema(schema) {  
var data = {                        
name: schema.id,                         
schema: {}                              
}                             
var newSchema = {}                    
var tmp = null                       
_.each(schema.properties, function(v, propName) {         
if(v['$ref'] != null) {                         
tmp = {                             

type: Schema.ObjectId,                   
ref: v['$ref']                       
}                            
} else {                      
tmp = translateComplexType(v) //{}          
}                            
newSchema[propName] = tmp                   
})                            
data.schema = new Schema(newSchema)   
return data                         
}                           
function translateTypeToJs(t) {              
if(t.indexOf('int') === 0) {                
t = "number"                         
}                         
return eval(t.charAt(0).toUpperCase() + t.substr(1))                  
}              This file contains some interesting functions that are used a lot from the models’ code. 
In Chapter 5  I mentioned that the schemas used with Swagger could potentially be reused to do other things, 
such as defining the models’ schemas. But to do this, 
we need a function to translate the standard JSON Schema into the nonstandard JSON format required by Mongoose to define a model. 
This is where the getModelFromSchema function comes into play; 
its code is meant to go over the structure of the JSON Schema and create a new, 
simpler JSON structure to be used as a Mongoose Schema.The other functions are more straightforward:    
connect: Connects to the database server and sets up the callbacks for both error and success cases.   
model: Accesses the model from outside. We could just directly access the models using the object models, 
but it’s always a good idea to provide a wrapper in case you ever need to add extra behaviors (such as checking for errors). 
/lib/config.js         
module.exports = {    
secretKey: 'this is a secret key, right here',          
server: {                          
name: 'ComeNRead API',                
version: '1.0.0',                    
port: 9000                         
},                           
database: {                
host: 'mongodb://localhost',    
dbname: 'comenread'                  
}                        
}           
This file is very straightforward; it simply exports a set of constant values to be used throughout the entire application.
modelsThis folder contains the actual code of each model. 
The definition of these resources won’t be found in these files because they’re only meant to define behavior. 
The actual properties are defined in the schemas folder (which, again, is being used both by the models and Swagger).
/models/index.js               
module.exports = function(db) { 
return {                      
"Book": require("./book")(db),   
"Booksale": require("./booksale")(db),    
"ClientReview": require("./clientreview")(db),   
"Client": require("./client")(db),              
"Employee": require("./employee")(db),          
"Store": require("./store")(db),                  
"Author": require("./author")(db)                    
}                           
}              Again, as in the other folders, the index.js file allows us to require every model at once,
and treat this folder like a module itself. 
The other thing of note here is the passing of the db object to every model, 
so that they can access the getModelFromSchema
function./models/author.js    
var mongoose = require("mongoose")   
jsonSelect = require('mongoose-json-select'),      
helpers = require("../lib/helpers"),             
_ = require("underscore")                       
module.exports = function(db) {                 
var schema = require("../schemas/author.js")    
var modelDef = db.getModelFromSchema(schema)     
modelDef.schema.plugin(jsonSelect, '-books')   
modelDef.schema.methods.toHAL = function() {     
var halObj = helpers.makeHAL(this.toJSON(),    
[{name: 'books', 'href': '/authors/' + this.id + '/books', 'title': 'Books'}])       
if(this.books.length > 0) {             
if(this.books[0].toString().length != 24) {      
halObj.addEmbed('books', _.map(this.books, function(e) { return e.toHAL() }))   
}                              }                          
return halObj                           
}                          
return mongoose.model(modelDef.name, modelDef.schema)                
}             
The code of the Author model shows the basic mechanics of loading the JSON Schema, 
transforming it into a Mongoose Schema, defining the custom behavior, and finally returning a new model.
The following defines the main custom behaviors:
The jsonSelect model allows us to define the attributes to add to or remove from the object when turning it into a JSON. 
We want to remove the embedded objects from the JSON representation,
because they will be added to the HAL JSON representation as embedded objects, rather than being part of the main object.T
he toHAL method takes care of returning the representation of the resource in JSON HAL format.
The links associated to the main object are defined manually. 
We could improve this by further customizing the code for the loading and transformation of the JSON Schemas of the models.   
NoteChecks like the following (inside the toHAL method) are meant to determine if the model has populated a reference, 
or if it is simply the id of the referenced object:     
if(this.books[0].toString().length != 24) {     
//…                            
}            
The following is the rest of the code inside the models folder, as you can appreciate, 
the same mechanics are duplicated on every 
case./models/book.js              
var mongoose = require("mongoose"),   
jsonSelect = require('mongoose-json-select'),   

helpers = require("../lib/helpers"),                              _ = require("underscore")                              module.exports = function(db) {                              var schema = require("../schemas/book.js")                              var modelDef = db.getModelFromSchema(schema)                              modelDef.schema.plugin(jsonSelect, '-stores -authors')                              modelDef.schema.methods.toHAL = function() {                              var halObj = helpers.makeHAL(this.toJSON(),                              [{name: 'reviews', href: '/books/' + this.id + '/reviews', title: 'Reviews'}])                              if(this.stores.length > 0) {                              if(this.stores[0].store.toString().length != 24) {                              halObj.addEmbed('stores', _.map(this.stores, function(s) { return { store: s.store.toHAL(), copies: s.copies } } ))                              }                              }                              if(this.authors.length > 0) {                              if(this.authors[0].toString().length != 24) {                              halObj.addEmbed('authors', this.authors)                              }                              }                              return halObj                              }                              return mongoose.model(modelDef.name, modelDef.schema)                              }              /models/booksale.js                var mongoose = require("mongoose"),                              jsonSelect = require('mongoose-json-select'),                              helpers = require("../lib/helpers"),                              _ = require("underscore")                              module.exports = function(db) {                              var schema = require("../schemas/booksale.js")                              var modelDef = db.getModelFromSchema(schema)                              modelDef.schema.plugin(jsonSelect, '-store -employee -client -books')                              modelDef.schema.methods.toHAL = function() {                              var halObj = helpers.makeHAL(this.toJSON())                              if(this.books.length > 0) {                              if(this.books[0].toString().length != 24) {                              halObj.addEmbed('books', _.map(this.books, function(b) { return b.toHAL() }))                              }                              }                              if(this.store.toString().length != 24) {                              halObj.addEmbed('store', this.store.toHAL())                              }                              if(this.employee.toString().length != 24) {                              halObj.addEmbed('employee', this.employee.toHAL())                              }                              if(this.client.toString().length != 24) {                              halObj.addEmbed('client', this.client.toHAL())                              }                              return halObj                              }                              return mongoose.model(modelDef.name, modelDef.schema)                              }              /models/client.js                var mongoose = require("mongoose"),                              jsonSelect = require('mongoose-json-select'),                              helpers = require("../lib/helpers"),                              _ = require("underscore")                              module.exports = function(db) {                              var schema = require("../schemas/client.js")                              var modelDef = db.getModelFromSchema(schema)                              modelDef.schema.methods.toHAL = function() {                              var halObj = helpers.makeHAL(this.toJSON())                              return halObj                              }                              return mongoose.model(modelDef.name, modelDef.schema)                              }              /models/clientreview.js                var mongoose = require("mongoose"),                              jsonSelect = require('mongoose-json-select'),                              helpers = require("../lib/helpers"),                              _ = require("underscore")                              module.exports = function(db) {                              var schema = require("../schemas/clientreview.js")                              var modelDef = db.getModelFromSchema(schema)                              modelDef.schema.methods.toHAL = function() {                              var halObj = helpers.makeHAL(this.toJSON())                              return halObj                              }                              modelDef.schema.post('save', function(doc, next) {                              db.model('Book').update({_id: doc.book}, {$addToSet: {reviews: this.id}}, function(err) {                              next(err)                              })                              })                              return mongoose.model(modelDef.name, modelDef.schema)                              }              /models/employee.js                var mongoose = require("mongoose"),                              jsonSelect = require('mongoose-json-select'),                              helpers = require("../lib/helpers"),                              _ = require("underscore")                              module.exports = function(db) {                              var schema = require("../schemas/employee.js")                              var modelDef = db.getModelFromSchema(schema)                              modelDef.schema.methods.toHAL = function() {                              var halObj = helpers.makeHAL(this.toJSON())                              return halObj                              }                              return mongoose.model(modelDef.name, modelDef.schema)                              }              /models/store.js                var mongoose = require("mongoose"),                              jsonSelect = require("mongoose-json-select"),                              _ = require("underscore"),                              helpers = require("../lib/helpers")                              module.exports = function(db) {                              var schema = require("../schemas/store.js")                              var modelDef = db.getModelFromSchema(schema)                              modelDef.schema.plugin(jsonSelect, '-employees')                              modelDef.schema.methods.toHAL = function() {                              var halObj = helpers.makeHAL(this.toJSON(),                              [{name: 'books', href: '/stores/' + this.id + '/books', title: 'Books'},                              {name: 'booksales', href: '/stores/' + this.id + '/booksales', title: 'Book Sales'}])                              if(this.employees.length > 0) {                              if(this.employees[0].toString().length != 24) {                              halObj.addEmbed('employees', _.map(this.employees, function(e) { return e.toHAL() }))                              }                              }                              return halObj                              }                              var model = mongoose.model(modelDef.name, modelDef.schema)                              return model                              }              request_schemasThis folder contains the JSON Schemas that will be used to validate the requests. They need to describe an object and its properties. We should be able to validate against the request object attribute that contains the parameters (normally request.params, but potentially something else, such as request.body).Due to the type of attributes we defined for our endpoints, there is really only one endpoint that we would want to validate: the getBookSales (GET /booksales) endpoint. It receives two date parameters, and we probably want to validate their format to be 100% certain that the dates are valid.Again, to provide the simplicity of usage that “convention over configuration” provides, our schema files must follow a very specific format, which is then used by the validator that we saw earlier:              /request_schemas/              [CONTROLLER NAME]              .js                          module.exports = {                          [ENDPOINT NICKNAME]              : {                          validate              : [TYPE              ],                          schema              : [JSON SCHEMA]                          }                          }            There are several pieces that need to be explained in the preceding code:CONTROLLER NAME: This means that the file for the schema needs to have the same name as the controller, all lowercase. And since we already did that for our controllers’ files, this mean the schemas for each controller will have to have the same name as each controller’s file.ENDPOINT NICKNAME: This should be the nickname given to the action when adding it to the controller (using the addAction method).TYPE: The type of object to validate. The only value supported right now is params, which references the query and path parameters received. This could be extended to support other objects.JSON SCHEMA: This is where we add the actual JSON Schema defining the request parameters.            Here is the actual code defining the validation for the getBookSales action./request_schemas/booksales.js                module.exports = {                              getbooksales: {                              validate:                'params'                ,                              schema:                {                              type: "object",                              properties: {                              start_date: {                              type: 'string',                              format:'date'                              },                              end_date: {                              type: 'string',                              format:'date'                              },                              store_id: {                              type: 'string'                              }                              }                              }                              }                              }              schemasThis folder contains the JSON Schema definitions of our resources, which also translate into the Mongoose Schemas when initializing our models.The level of detail provided in these files is very important, because it also translates into the actual Mongoose model. This means that we could define things such as ranges of values and format patterns, which would be validated by Mongoose when creating the new resources.For instance, let’s take a look at ClientReview, a schema that makes use of such capability./schemas/clientreview.js                module.exports = {                              "id": "ClientReview",                              "properties": {                              "client": {                              "$ref": "Client",                              "description": "The client who submits the review"                              },                              "book": {                              "$ref": "Book",                              "description": "The book being reviewed"                              },                              "review_text": {                              "type": "string",                              "description": "The actual review text"                              },                              "stars": {                              "type": "integer",                              "description": "The number of stars, from 0 to 5",                              "min": 0,                              "max": 5                              }                              }                              }              The stars attribute is clearly setting the maximum and minimum values that we can send when saving a new review. If we tried to send an invalid number, then we would get an error like the one shown in Figure 7-2.Figure 7-2.An error when trying to save an invalid value in a validated model            When defining schemas that reference others, remember to correctly name the reference (the name of each schema is given by the id property). So if you correctly set up the reference, the getModelFromSchema method of the db module will also properly set up the reference in Mongoose (this works both for direct reference and for collections).Here is the main file for this folder; the index.js works like the index files in the other folders:              module.exports = {                          models: {                          BookSale: require("./booksale"),                          Book: require("./book"),                          Author: require("./author"),                          Store: require("./store"),                          Employee: require("./employee"),                          Client: require("./client"),                          ClientReview: require("./clientreview")                          }                          }            Finally, here are the rest of the schemas defined for the project./schemas/author.js                module.exports = {                              "id": "Author",                              "properties": {                              "name": {                              "type": "string",                              "description": "The full name of the author"                              },                              "description": {                              "type": "string",                              "description": "A small bio of the author"                              },                              "books": {                              "type": "array",                              "description": "The list of books published on at least one of the stores by this author",                              "items": {                              "$ref": "Book"                              }                              },                              "website": {                              "type": "string",                              "description": "The Website url of the author"                              },                              "avatar": {                              "type": "string",                              "description": "The url for the avatar of this author"                              }                              }                              }              /schemas/book.js                module.exports = {                              "id": "Book",                              "properties": {                              "title": {                              "type": "string",                              "description": "The title of the book"                              },                              "authors": {                              "type":"array",                              "description":"List of authors of the book",                              "items": {                              "$ref": "Author"                              }                              },                              "isbn_code": {                              "description": "Unique identifier code of the book",                              "type":"string"                              },                              "stores": {                              "type": "array",                              "description": "The stores where clients can buy this book",                              "items": {                              "type": "object",                              "properties": {                              "store": {                              "$ref": "Store",                              },                              "copies": {                              "type": "integer"                              }                              }                              }                              },                              "genre": {                              "type": "string",                              "description": "Genre of the book"                              },                              "description": {                              "type": "string",                              "description": "Description of the book"                              },                              "reviews": {                              "type": "array",                              "items": {                              "$ref": "ClientReview"                              }                              },                              "price": {                              "type": "number",                              "minimun": 0,                              "description": "The price of this book"                              }                              }                              }              /schemas/booksale.js                module.exports = {                              "id": "BookSale",                              "properties": {                              "date": {                              "type":"date",                              "description": "Date of the transaction"                              },                              "books": {                              "type": "array",                              "description": "Books sold",                              "items": {                              "$ref": "Book"                              }                              },                              "store": {                              "type": "object",                              "description": "The store where this sale took place",                              "type": "object",                              "$ref": "Store"                              },                              "employee": {                              "type": "object",                              "description": "The employee who makes the sale",                              "$ref": "Employee"                              },                              "client": {                              "type": "object",                              "description": "The person who gets the books",                              "$ref": "Client",                              },                              "totalAmount": {                              "type": "integer"                              }                              }                              }              /schemas/client.js                module.exports = {                              "id": "Client",                              "properties": {                              "name": {                              "type": "string",                              "description": "Full name of the client"                              },                              "address": {                              "type": "string",                              "description": "Address of residence of this client"                              },                              "phone_number": {                              "type": "string",                              "description": "Contact phone number for the client"                              },                              "email": {                              "type": "string",                              "description": "Email of the client"                              }                              }                              }              /schemas/employee.js                module.exports = {                              "id": "Employee",                              "properties": {                              "first_name": {                              "type": "string",                              "description": "First name of the employee"                              },                              "last_name": {                              "type": "string",                              "description": "Last name of the employee"                              },                              "birthdate": {                              "type": "string",                              "description": "Date of birth of this employee"                              },                              "address": {                              "type": "string",                              "description": "Address for the employee"                              },                              "phone_numbers": {                              "type": "array",                              "description": "List of phone numbers of this employee",                              "items": {                              "type": "string"                              }                              },                              "email": {                              "type": "string",                              "description": "Employee's email"                              },                              "hire_date": {                              "type": "string",                              "description": "Date when this employee was hired"                              },                              "employee_number": {                              "type": "number",                              "description": "Unique identifier of the employee"                              }                              }                              }              /schemas/store.js                module.exports = {                              "id": "Store",                              "properties": {                              "name": {                              "type": "string",                              "description": "The actual name of the store"                              },                              "address": {                              "type": "string",                              "description": "The address of the store"                              },                              "state": {                              "type": "string",                              "description": "The state where the store resides"                              },                              "phone_numbers": {                              "type": "array",                              "description": "List of phone numbers for the store",                              "items": {                              "type": "string"                              }                              },                              "employees": {                              "type": "array",                              "description": "List of employees of the store",                              "items": {                              "$ref": "Employee"                              }                              }                              }                              }              swagger-uiThis folder contains the downloaded Swagger UI project, so we will not go over this particular code; however, I will mention the minor modifications we’ll need to do to the index.html file (located at the root of the swagger-ui folder) to get the UI to properly load.The changes needed are three very simple ones:1.Edit the routes for all the resources loaded (CSS and JS files) to start with swagger-ui/. 2.Change the URL for the documentation server to http://localhost:9000/api-docs (around line 31). 3.Uncomment the block of code in line 73. Set the right value to the apiKey variable (set it to 777).             With those changes, the UI should be able to load correctly and allow you to start testing your API.Root FolderThis is the root of the project. There are only two files here: the main index.js and the package.json file that contains the dependencies and other project attributes./package.json                {                              "name": "come_n_read",                              "version": "1.0.0",                              "description": "",                              "main": "index.js",                              "scripts": {                              "test": "echo \"Error: no test specified\" && exit 1"                              },                              "author": "",                              "license": "ISC",                              "dependencies": {                              "colors": "^1.0.3",                              "halson": "^2.3.1",                              "mongoose": "^3.8.23",                              "mongoose-json-select": "^0.2.1",                              "restify": "^2.8.5",                              "swagger-node-restify": "^0.1.2",                              "tv4": "^1.1.9",                              "tv4-formats": "^1.0.0",                              "underscore": "^1.7.0"                              }                              }              The most interesting part of this file is the list of dependencies. The rest was autogenerated using the init option of the npm command-line tool./index.js                var restify = require("restify"),                              colors = require("colors"),                              lib = require("./lib"),                              swagger = require("swagger-node-restify"),                              config = lib.config                              var server = restify.createServer(lib.config.server)                              //Middleware setup                              server.use(restify.queryParser())                              server.use(restify.bodyParser())                              restify.defaultResponseHeaders = function(data) {                              this.header('Access-Control-Allow-Origin', '*')                              }                              ///Middleware to check for valid api key sent                              server.use(function(req, res, next) {                              //We move forward if we're dealing with the swagger-ui or a valid key                              if(req.url.indexOf("swagger-ui") != -1 || lib.helpers.validateKey(req.headers.hmacdata || '', req.params.api_key, lib)) {                              next()                              } else {                              res.send(401, { error: true, msg: 'Invalid api key sent'})                              }                              })                              /**                              Validate each request, as long as there is a schema for it                              */                              server.use(function(req, res, next) {                              var results = lib.schemaValidator.validateRequest(req)                              if(results.valid) {                              next()                              } else {                              res.send(400, results)                              }                              })                              //the swagger-ui is inside the "swagger-ui" folder                              server.get(/^\/swagger-ui(\/.*)?/, restify.serveStatic({                              directory: __dirname + '/',                              default: 'index.html'                              }))                              //setup section                              swagger.addModels(lib.schemas)                              swagger.setAppHandler(server)                              lib.helpers.setupRoutes(server, swagger, lib)                              swagger.configureSwaggerPaths("", "/api-docs", "") //we remove the {format} part of the paths, to                              swagger.configure('                http://localhost:9000                ', '0.1')                              //start the server                              server.listen(config.server.port, function() {                              console.log("Server started succesfully…".green)                              lib.db.connect(function(err) {                              if(err) console.log("Error trying to connect to database: ".red, err.red)                              else console.log("Database service successfully started".green)                              })                              })              And finally, the main file, the one that starts it all up, the index.js. There are four distinct sections to this file:The initial section, which requires all needed modules and instantiates the server.The middleware setup section, which handles setting up all pieces of middleware (we’ll go over this in a bit).The setup section, which handles loading models, controllers, setting up routes, and whatnot.The server start section, which starts the web server and the database client.            The initial and final sections of the file don’t really require much explanation since they’re pretty self-explanatory, so let’s go over the other two.
